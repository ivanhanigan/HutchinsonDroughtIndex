#+TITLE:HutchinsonDroughtIndex 
#+AUTHOR: Ivan Hanigan
#+email: ivan.hanigan@anu.edu.au
#+LaTeX_CLASS: article
#+LaTeX_CLASS_OPTIONS: [a4paper]
#+LATEX: \tableofcontents
-----
* TODO-list
- http://mobile.abc.net.au/news/2015-07-06/drought-worries-rising-victoria-south-australia-rainfall-lowest/6597870
* Introduction
** DESCRIPTION
*** COMMENT DESCRIPTION-code
#+name:DESCRIPTION
#+begin_src R :session *R* :tangle DESCRIPTION :exports none :eval no :padline no
  Package: HutchinsonDroughtIndex
  Type: Package
  Title: Hutchinson's Drought Index  
  Version: 1.1
  Date: 2015-11-06
  Author: ivanhanigan, lucianaporforio, Michael Hutchinson
  Maintainer: <ivan.hanigan@gmail.com>
  Depends: raster, rgdal, zoo
  Description: drought function
  License: GPL (>= 2)
  
#+end_src

** run tests
#+name:test_project
#+begin_src R :session *R* :tangle test_project.r :exports none :eval no
  ################################################################
  # name:test_project
  require(testthat)
  test_dir('tests')
  
#+end_src

** package doc
#+name:swishdbtools-package
#+begin_src R :session *R* :tangle man/HutchinsonDroughtIndex-package.Rd :exports none :eval no
\name{HutchinsonDroughtIndex-package}
\alias{HutchinsonDroughtIndex-package}
\alias{HutchinsonDroughtIndex}
\docType{package}
\title{
Hutchinson Drought Index
}
\description{
Climatic Drought
}
\details{
\tabular{ll}{
Package: \tab HutchinsonDroughtIndex\cr
Type: \tab Package\cr
Version: \tab 1.0\cr
Date: \tab 2014-01-14\cr
License: \tab GPL2\cr
}
~~ An overview of how to use the package, including the most important functions ~~
}
\author{


Maintainer: Who to complain to <ivan.hanigan@gmail.com>

}
\references{

}
\keyword{ package }
\seealso{
~~ Optional links to other man pages, e.g. ~~
~~ \code{\link[<pkg>:<pkg>-package]{<pkg>}} ~~
}
\examples{

}

#+end_src

** NAMESPACE
#+name:NAMESPACE
#+begin_src txt :tangle no :exports reports :eval no :padline
exportPattern("^[[:alpha:]]+")
#+end_src

* Functions
** drought_index_stations
*** R-drought_index_stations
#+name:drought_index_stations
#+begin_src R :session *R* :tangle R/drought_index_stations.r :exports none :eval no
  #' @name drought_index_stations
  #' @title Drought Index For Stations
  #' @param data a dataframe with date, year month and rain
  #' @param years the number of years in the time series
  #' @param droughtThreshold the level of dryness below which a drought begins
  #' @return dataframe with droughtIndices
  #' @export
  
  
  drought_index_stations<-function(data,years,droughtThreshold=.375){
  # a drought index based on integrated six-monthly rainfall percentiles.
  # based on Professor Mike Hutchinson's work described in 
  # Smith D, Hutchinson M, McArthur R. Climatic and Agricultural Drought: Payments and Policy. 
  # Canberra, ACT: Centre for Resource and Environmental Studies, Australian National University. 1992.  
  
  # Ivan C Hanigan
  # June 2011.
    
  ################################################################################
  ## Copyright 2011, Ivan C Hanigan <ivan.hanigan@gmail.com> and Michael F Hutchinson
  ## This program is free software; you can redistribute it and/or modify
  ## it under the terms of the GNU General Public License as published by
  ## the Free Software Foundation; either version 2 of the License, or
  ## (at your option) any later version.
  ## 
  ## This program is distributed in the hope that it will be useful,
  ## but WITHOUT ANY WARRANTY; without even the implied warranty of
  ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ## GNU General Public License for more details.
  ## Free Software
  ## Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
  ## 02110-1301, USA
  ################################################################################
  
  
  # my input data are always a data.frame with 4 columns 'date','year','month','rain'
   
  #calculate M month totals
  # started with 6 (current and prior months)
  x<-ts(data[,4],start=1,end=c(years,12),frequency=12)
  x<-c(rep(NA,5),x+lag(x,1)+lag(x,2)+lag(x,3)+lag(x,4)+lag(x,5))
  # TASK need to use rollapply?
  data$sixmnthtot<-x
  data<-na.omit(data)
  
  # rank in percentage terms with respect to the rainfall totals 
  # for the same sequence of 6-months over all years of record
  dataout_final=matrix(nrow=0,ncol=7)
  
  for(i in 1:12){
          x<-data[data$month==i,5]
          #x<-na.omit(x)
          y<-(rank(x)-1)/(length(x)-1)
          # checkpct<-cbind(data[data$month==i,],y)
          # plot(checkpct$sixmnthtot,checkpct$y)
          # rescale between -4 and +4 to replicate palmer index 
          z<-8*(y-.5)
          # defualts set the threshold at -1 which is upper limit of
          # mild drought in palmer index
          # (3/8ths, or the 37.5th percentile) 
          drought<-x<=quantile(x,droughtThreshold)
          # calculate the drought index for any months that fall below the threshold
          zd<-z*drought
          # save out to the data
          dataout<-data[data$month==i,]
          dataout$index<-z
          dataout$indexBelowThreshold<-zd
          dataout_final=rbind(dataout_final,dataout)
          }
                  
  data<-dataout_final[order(dataout_final$date),]
  
  # now calculate the indices
  # newnode COUNTS
  data$count<-as.numeric(0)
  # OLD and SLOW
  # for(j in 2:nrow(data)){
          # data$count[j]<-ifelse(data$indexBelowThreshold[j]==0,0,
          # ifelse(data$indexBelowThreshold[j-1]!=0,1+data$count[j-1],
          # 1)
          # )
          # }
  
  # NEW and FAST
  # counts can be done with this funky bit of code 
  x<-data$index<=-1
  xx <- (cumsum(!x) + 1) * x 
  x2<-(seq_along(x) - match(xx, xx) + 1) * x 
  data$count<-x2
  
  # OLD and SLOW enhanced drought revocation threshold 
  # TASK make NEW and FAST? or add as an option?
  # In the enhanced version rather than stop counting when the rescaled percentiles rise above -1.0, 
  # we keep counting the months (or adding the negative anomalies) 
  # if the rescaled percentile is below 0.0 AND the drought threshold has already been reached. 
  # If the threshold has not been reached, then stop counting (or adding) as before 
  # if the rescaled percentile rises above -1.0.
  
  data$count2<-data$count
  # j=1080 # 1980-06
  # data[j,]
  
  for(j in 2:nrow(data)){ 
  data$count2[j] <- if(data$count2[j-1] >= 5 & data$index[j] <= 0){
          data$count2[j-1] + 1
          } else {                
          # ifelse(data$count[j-1] > 0 & data$index[j] < 0, 1+data$count[j-1],
          data$count2[j]
          }
  }
  ############################################################
  # newnode SUMS
  # NEW and FAST? or add as an option?
  data$sums<-as.numeric(0)
  y <- ifelse(data$index >= -1, 0, data$index)
  f <- data$index < -1
  f <- (cumsum(!f) + 1) * f 
  z <- unsplit(lapply(split(y,f),cumsum),f)
  data$sums <- z
  # OLD and SLOW
  # for(j in 2:nrow(data)){
          # data$sums[j]<-ifelse(data$indexBelowThreshold[j]==0,0,
          # ifelse(data$indexBelowThreshold[j-1]!=0,
          # data$indexBelowThreshold[j]+data$sums[j-1],
          # data$indexBelowThreshold[j]))
          # }
          
  # OLD and SLOW
  # TASK make NEW and FAST
  data$sums2<-data$sums
  # j=1069 # 1980-06
  # data[j,]
  
  for(j in 2:nrow(data)){ 
  data$sums2[j] <- if(data$sums2[j-1] <= -17.5 & data$index[j] <= 0){
          data$sums2[j-1] + data$index[j]
          } else {                
          # ifelse(data$count[j-1] > 0 & data$index[j] < 0, 1+data$count[j-1],
          data$sums2[j]
          }
  }
  
  droughtIndices<-data
  return(droughtIndices)
  }
  
  
  
#+end_src
*** test-drought_index_stations
#+name:drought_index_stations
#+begin_src R :session *R* :tangle tests/test-drought_index_stations.r :exports none :eval no
  ################################################################
  # name:drought_index_stations
  analyte <- read.table("~/projects/HutchinsonDroughtIndex/inst/extdata/prcphq.046037.month.txt", quote="\"", skip = 1, nrows = 1440)
  
  # clean
  str(analyte)
  head(analyte);tail(analyte)
  
  analyte <- data.frame(analyte[,1], substr(analyte[,1], 1,4) , substr(analyte[,1],5,6), analyte[,3])
  names(analyte) <- c('date',  'year' , 'month' ,'rain')
  str(analyte)
  analyte$year <- as.numeric(as.character(analyte$year))
  analyte$month <- as.numeric(as.character(analyte$month))
  str(analyte)
  subset(data.frame(table(na.omit(analyte)[,"year"])), Freq < 12)
  # are all months present?
  
  # do
  drt <- drought_index_stations(data=analyte,years=length(names(table(analyte$year))),droughtThreshold=.375)
  
  # report
  summary(drt)
  with(drt, plot(as.Date(date), count, "l"))
  abline(5,0)
  par(new=T)
  with(drt, plot(as.Date(date), -1*sums, col= "red", type="l"))
  
#+end_src
*** man-drought_index_stations
#+name:drought_index_stations
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:drought_index_stations

#+end_src

** drought_index_grids
*** R-drought_index_grids
# name:drought_index_grids

## TODO-list: 
# count2 and sums, convert matrices to bricks.
# set it up to work on subsets of the grid and put them back together after

#+name:drought_index_grids
#+begin_src R :session *R* :tangle R/drought_index_grids.r :exports none :eval no
  #' @name drought_index_grids
  #' @title drought index using grids
  #' @param rasterbrick a stack of grids
  #' @param startyear the start year
  #' @param endyear the end year
  #' @param droughtThreshold the level of dryness
  #' @return dataframe with droughtIndices
  #' @export
  
  drought_index_grids <- function(rasterbrick,startyear,endyear,droughtThreshold=.375){
      
    b<-getValuesBlock(rasterbrick, row=500, nrows=5, col=500, ncols=5)
    # TODO estimate the max and min date from the data filenames
    x<-apply(b, 1, function(x) ts(x,start=c(startyear, 01),end=c(endyear,12),frequency=12))
    sixmnthtot<-apply(x, 2, function(x) c(rep(NA,5),x+lag(x,1)+lag(x,2)+lag(x,3)+lag(x,4)+lag(x,5)))
    # TODO it might be faster to use zoo::rollapply,
    # and also we can make the lag length variable
     
    ##rank
    # TODO select for each month ie all Januarys are ranked seperate from Febs etc
    rank <- apply(x, 2, function(x) {return((rank(x)-1)/(length(x)-1))})
    index <- apply(rank, 2, function(x) 8*(x-.5)) #to be a brick
    # .375 is refering to palmer's benchmark but we could let the user vary this
    drought <- apply(x, 2, function(x) x<=quantile(x,droughtThreshold)) 
    indexBelowThreshold <- index*drought #to be a  brick
     
    ##count
    x1 <- index<=-1
    x2 <- apply(x1, 2, function(x) (cumsum(!x) + 1) * x )
    seq <- apply(x1, 2, function(x) seq_along(x))
    match <- apply(x2, 2, function(x) match(x,x))
    count<- (seq - match + 1) * x1 #double check #to be a brick
    return(count)
  }
  
#+end_src
*** test-drought_index_grids
#+name:drought_index_grids
#+begin_src R :session *R* :tangle tests/test-drought_index_grids.r :exports none :eval no
################################################################
# name:drought_index_grids
if(!require(devtools)) install.packages("devtools", depend = T); require(devtools)
install_github("HutchinsonDroughtIndex", "ivanhanigan")
require(HutchinsonDroughtIndex)
wd <- getwd()
setwd("~/data/AWAP_GRIDS/data")
##Lu 13-14 Jan 2014
require(raster); require(rgdal)
##path?
awap.grids = dir(pattern = "grid$", full.names=T)
#  list.files('AWAP_GRIDS', pattern=glob2rx('totals*.grid'), full.names=T)
for(i in 1:12){
  #i = 1
  #file.copy(awap.grids[i], sprintf("foo%s.grid", i))}
  r <- raster(awap.grids[i])
  #str(r)
  #image(r)
  fname <- gsub(".grid",".tif", awap.grids[i])
  # TODO project this please lu!
  writeRaster(r, filename= fname, type = "GTiff")
  #file.remove(awap.grids[i])
}
## for some reason brick or stack only don't work, both together do
awap.grids <- dir(pattern = 'tif')[1:12]
rb <- brick(stack(awap.grids)) #takes too l

## I'm not sure what's more efficient, if changing the drought function 
## to do the cal on matrices or just running the function on the vectors

##option 1 modif function
ct <- drought_index_grids(rasterbrick = rb,startyear = 1900, endyear=1900, droughtThreshold=.375)
plot(ct[,1], type = "l")

#+end_src
*** man-drought_index_grids
#+name:drought_index_grids
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:drought_index_grids

#+end_src

** drought_index_future
*** R-drought_index_future
#+begin_src R :session *shell* :tangle R/drought_index_future.r :exports none :eval no :padline no
  #' @name drought_index_future
  #' @title Drought Index For Stations for future projected rainfall
  #' @param data a dataframe with date (future), year (future), month, rain (past) and rain_projected
  #' @param years the number of years in the time series
  #' @param droughtThreshold the level of dryness below which a drought begins
  #' @return dataframe with droughtIndices
  #' @export
  
  drought_index_future <- function(data,years,droughtThreshold=.375){
  # a drought index based on integrated six-monthly rainfall percentiles.
  # based on Professor Mike Hutchinson's work described in
  # Smith D, Hutchinson M, McArthur R. Climatic and Agricultural Drought: Payments and Policy.
  # Canberra, ACT: Centre for Resource and Environmental Studies, Australian National University. 1992.
  
  # Ivan C Hanigan
  # Nov 2015.
  # GPL2
  # for updates please see https://github.com/ivanhanigan/HutchinsonDroughtIndex.
  
  # my input data are always a data.frame with 5 columns 'date (future','year(future)','month','rain(past)' 'rain_projected'
  
  #### PAST DISTRIBUTION  
  #calculate M month totals
  # started with 6 (current and prior months)
    
  # ASSUMES PAST RAIN IS IN FOURTH COLUMN  
  x<-ts(data[,4],start=1,end=c(years,12),frequency=12)
  x<-c(rep(NA,5),x+lag(x,1)+lag(x,2)+lag(x,3)+lag(x,4)+lag(x,5))
  data$sixmnthtot<-x
  #data<-na.omit(data)
  #### FUTURE RAIN
  # ASSUMES FUTURE IS IN COL 5
  x2<-ts(data[,5],start=1,end=c(years,12),frequency=12)
  x2<-c(rep(NA,5),x2+lag(x2,1)+lag(x2,2)+lag(x2,3)+lag(x2,4)+lag(x2,5))
  data$sixmnthtot2<-x2
  data<-na.omit(data)
  #head(data)
  #tail(data)
  # rank in percentage terms with respect to the rainfall totals
  # for the same sequence of 6-months over all years of record
  dataout_final=matrix(nrow=0,ncol=7)
  
  for(i in 1:12){
    #i =1
    # col sixmnthto is the past rain, sixmnthtot2 is the future rain
  x<-data[data$month==i,'sixmnthtot']
  x2<-data[data$month==i,'sixmnthtot2']
  
  #x<-na.omit(x)
  # get distribution of FUTURE RAIN
  y <- (rank(x2)-1)/(length(x2)-1)
  # checkpct<-cbind(data[data$month==i,],y)
  # plot(checkpct$sixmnthtot,checkpct$y)
  # rescale between -4 and +4 to replicate palmer index
  z <- 8 * (y - .5)
  # defaults set the threshold at -1 which is upper limit of mild drought in palmer index (3/8ths, or the 37.5th percentile)
  # use future rain < past rain threshold
  drought <- x2 <= quantile(x,droughtThreshold)
  
  # calculate the drought index for any months that fall below the threshold
  zd <- z * drought
  # save out to the data
  dataout<-data[data$month==i,]
  dataout$index<-z
  dataout$indexBelowThreshold<-zd
  dataout_final=rbind(dataout_final,dataout)
  }
  
  data<-dataout_final[order(dataout_final$date),]
  
  # now calculate the indices
  data$count<-as.numeric(0)
  
  for(j in 2:nrow(data)){
    data$count[j] <- ifelse(data$indexBelowThreshold[j]==0,0,
      ifelse(data$indexBelowThreshold[j-1]!=0,1+data$count[j-1],1)
    )
  }
  
  # enhanced drought revocation threshold
  # In the enhanced version rather than stop counting when the rescaled percentiles rise above -1.0,
  # we keep counting the months (or adding the negative anomalies)
  # if the rescaled percentile is below 0.0 AND the drought threshold has already been reached.
  # If the threshold has not been reached, then stop counting (or adding) as before
  # if the rescaled percentile rises above -1.0.
  
  data$count2<-data$count
  # j=1080 # 1980-06
  # data[j,]
  
  for(j in 2:nrow(data)){
    data$count2[j] <- if(data$count2[j-1] >= 5 & data$index[j] <= 0){
      data$count2[j-1] + 1
    } else {
  # ifelse(data$count[j-1] > 0 & data$index[j] < 0, 1+data$count[j-1],
      data$count2[j]
    }
  }
  
  
  data$sums<-as.numeric(0)
  
  for(j in 2:nrow(data)){
  data$sums[j]<-ifelse(data$indexBelowThreshold[j]==0,0,
  ifelse(data$indexBelowThreshold[j-1]!=0,
  data$indexBelowThreshold[j]+data$sums[j-1],
  data$indexBelowThreshold[j]))
  }
  
  
  data$sums2<-data$sums
  # j=1069 # 1980-06
  # data[j,]
  
  for(j in 2:nrow(data)){
  data$sums2[j] <- if(data$sums2[j-1] <= -17.5 & data$index[j] <= 0){
  data$sums2[j-1] + data$index[j]
  } else {
  # ifelse(data$count[j-1] > 0 & data$index[j] < 0, 1+data$count[j-1],
  data$sums2[j]
  }
  }
  #plot(data$date, data$count, type = "l")
  #abline(5,0)
  droughtIndices<-data
  
  return(droughtIndices)
  }
  
#+end_src

*** test-drought_index_future

#+name:drought_index_future
#+begin_src R :session *R* :tangle tests/test-drought_index_future.r :exports none :eval no
  ################################################################
  # name:drought_index_stations
  # for info see
  # https://github.com/ivanhanigan/GARNAUT_CLIMATE_CHANGE_REVIEW
  # drought futures sub project
  
  ## dat <- read.csv("~/projects/GARNAUT_CLIMATE_CHANGE_REVIEW/drought_futures/data/rain_future_estimated_dry.csv", stringsAsFactors = F)
  
  ## # drop the first year as only half
  ## names(dat)
  
  ## head(dat)
  ## dat$date <- as.Date(paste(dat$year_future, dat$month, 1, sep = "-"))
  
  ## sds <- names(table(dat$sd_group))
  ## sds
  
  ## # save a test dataset for developing the fucntion with, transfer to
  ## # hutch package
  ## sd_i <- "Central West"
  ## dat2 <- dat[dat$year > 1890 & dat$sd_group == sd_i, c('date','year_future','month','avrain','rain_projected')]
  ## summary(dat2)
  ## head(dat2, 24)
  ## plot(dat2$date, dat2$avrain, type = "l")
  # write.csv(dat2, "~/projects/HutchinsonDroughtIndex/inst/extdata/GARNAUT_CLIMATE_CHANGE_drought_futures_dry_central_west_sd07.csv", row.names = F)
  
  
  analyte <- read.csv("~/projects/HutchinsonDroughtIndex/inst/extdata/GARNAUT_CLIMATE_CHANGE_drought_futures_dry_central_west_sd07.csv")
  
  # clean
  str(analyte)
  head(analyte);tail(analyte)
  
  # do
  drt <- drought_index_future(data=analyte,years=length(names(table(analyte$year_future))),droughtThreshold=.375)
  
  # report
  summary(drt)
  with(drt, plot(as.Date(date), count, "l"))
  abline(5,0)
  par(new=T)
  with(drt, plot(as.Date(date), -1*sums, col= "red", type="l"))
  
  
  
  
#+end_src

* Vignettes
** COMMENT HutchinsonDroughtIndex-code
#+begin_src tex :tangle inst/doc/HutchinsonDroughtIndex.Rnw :eval no :padline no
\documentclass{article}
%\VignetteIndexEntry{HutchinsonDroughtIndex}
\begin{document}
\SweaveOpts{concordance=TRUE}
\begin{center}
\Large
{\tt HutchinsonDroughtIndex} Package Vignette
\normalsize
\end{center}
The following figure illustrates a sequence of numbers.
<<keep.source=TRUE>>=
library('HutchinsonDroughtIndex')
x <- rnorm(100,1,2)
x
@
\end{document}
#+end_src
